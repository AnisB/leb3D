// CBVs
#define GLOBAL_CB_BINDING_SLOT b0
#define GRID_CB_BINDING_SLOT b1

// SRVs
#define DENSITY_BUFFER_0_BINDING_SLOT t0
#define DENSITY_BUFFER_1_BINDING_SLOT t1

// Includes
#include "shader_lib/common.hlsl"
#include "shader_lib/constant_buffers.hlsl"
#include "shader_lib/grid_utilities.hlsl"

static const float3 vertices[] = {
    float3(0.0, 0.0, 0.0),  // 0: Bottom-left-back
    float3(1.0f, 0.0, 0.0),  // 1: Bottom-right-back
    float3(1.0f,  1.0f, 0.0),  // 2: Top-right-back
    float3(0.0,  1.0f, 0.0),  // 3: Top-left-back
    float3(0.0, 0.0,  1.0f),  // 4: Bottom-left-front
    float3(1.0f, 0.0,  1.0f),  // 5: Bottom-right-front
    float3(1.0f,  1.0f,  1.0f),  // 6: Top-right-front
    float3(0.0,  1.0f,  1.0f)   // 7: Top-left-front
};

// Define the indices to form triangles using the vertices (12 triangles, 6 faces)
static const uint32_t indices[] = {
    // Front face
    4, 5, 6,  // Triangle 1
    4, 6, 7,  // Triangle 2

    // Back face
    0, 1, 2,  // Triangle 1
    0, 2, 3,  // Triangle 2

    // Left face
    0, 3, 7,  // Triangle 1
    0, 7, 4,  // Triangle 2

    // Right face
    1, 5, 6,  // Triangle 1
    1, 6, 2,  // Triangle 2

    // Top face
    3, 2, 6,  // Triangle 1
    3, 6, 7,  // Triangle 2

    // Bottom face
    0, 1, 5,  // Triangle 1
    0, 5, 4   // Triangle 2
};

struct VertexInput
{
    uint instanceID : SV_InstanceID;
    uint vertexID : SV_VertexID;
};

struct VertexOutput
{
    float4 position : SV_POSITION;
    float3 positionRWS : POSITION_RWS;
    float3 color : COLOR;
};

VertexOutput vert(VertexInput input)
{
    // Initialize the output structure
    VertexOutput output;
    output = (VertexOutput)0;

    // Coordinates of this
    uint32_t x = input.instanceID % _GridResolution.x;
    uint32_t y = (input.instanceID / _GridResolution.x) % _GridResolution.y;
    uint32_t z = input.instanceID / _GridResolution.x / _GridResolution.y;

    // Read the density of this instance
    float density = grid_density(uint3(x, y, z)) * 0.05;

    // index of the vertex
    uint idx = indices[input.vertexID];
    float3 v = vertices[idx] / (float3)_GridResolution + float3(x, y, z) / (float3)_GridResolution - float3(0.5, 0.5, 0.5);

    // Output for the next stage
    output.positionRWS = v / _GridScale - _CameraPosition;
    output.position = mul(_ViewProjectionMatrix, float4(output.positionRWS, 1.0));
    output.color = density > 0.0 ? float3(1.0, 0.0, 0.0) : float3(0.5, 0.5, 0.5);
    return output;
}

struct GeometryInput
{
    float4 positionCS : SV_POSITION;
    float3 positionRWS : POSITION_RWS;
    float3 color : COLOR;
};

struct GeometryOutput
{
    float4 positionCS : SV_POSITION;
    float3 positionRWS : POSITION_RWS;
    float3 color : COLOR;
    float3 dist : DISTANCE;
};

[maxvertexcount(3)]
void geom(triangle GeometryInput input[3], inout TriangleStream<GeometryOutput> outStream)
{   
    // Compute the vectors and the area
    float2 p0 = clip_space_to_pixel(input[0].positionCS, _ScreenSize.xy);
    float2 p1 = clip_space_to_pixel(input[1].positionCS, _ScreenSize.xy);
    float2 p2 = clip_space_to_pixel(input[2].positionCS, _ScreenSize.xy);
    float2 v[3] = {p2 - p1, p2 - p0, p1 - p0};
    float area = abs(v[1].x * v[2].y - v[1].y * v[2].x);

    // Emit the vertices
    GeometryOutput output = (GeometryOutput)0;
    for (uint vertID = 0; vertID < 3; ++vertID)
    {
        output.positionCS = input[vertID].positionCS;
        output.color = input[vertID].color;
        output.positionRWS = input[vertID].positionRWS;
        output.dist = 0.0;
        output.dist[vertID] = area * rsqrt(dot(v[vertID],v[vertID]));
        outStream.Append(output);
    }
    outStream.RestartStrip();
}

struct PixelInput
{
    float4 positionCS : SV_POSITION;
    float3 positionRWS : POSITION_RWS;
    float3 color : COLOR;
    float3 dist : DISTANCE;
};

struct PixelOutput
{
    float4 attachment0 : SV_Target0;
};

float3 apply_wireframe(float3 color, float3 wireFrameColor, float wireframeSize, float3 dist)
{
    if (wireframeSize > 0.0)
    {
        float3 d2 = dist * dist;
        float nearest = min(min(d2.x, d2.y), d2.z);
        float f = exp2(-nearest / wireframeSize);
        color = lerp(color, wireFrameColor, f);
    }
    return color;
}

PixelOutput frag(PixelInput input)
{
    // Evaluate the distance to camera
    float distanceToCamera = length(input.positionRWS);

     // View vector
    float3 viewWS = -input.positionRWS / max(distanceToCamera, 0.00001);

    // Normal vector
    float3 normalWS = normalize(cross(ddx(input.positionRWS), ddy(input.positionRWS)));
    float3 roughness = 0.8;
    float3 diffuseColor = float3(1.0, 1.0, 1.0);

    // NdotV
    float NdotV = dot(viewWS, normalWS);

    // Evaluate the wireframe
    input.color = apply_wireframe(input.color * 0.01, float3(0.2, 0.2, 0.2), 0.5, input.dist);

    PixelOutput output;
    output.attachment0 = float4(input.color, 1.0);
    return output;
}